name: CI

on:
  push:
    branches:
      - 'feature/**'
  pull_request:
    branches: [ main, develop ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Compose
        uses: docker/setup-buildx-action@v3

      - name: Create .env file
        run: |
          cat << EOF > .env
          HTTP_HOST=${{ secrets.HTTP_HOST }}
          REDIS_HOST=${{ secrets.REDIS_HOST }}
          DB_HOST=${{ secrets.DB_HOST }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_S3_FORCE_PATH_STYLE=${{ secrets.AWS_S3_FORCE_PATH_STYLE }}
          AWS_S3_ENDPOINT=${{ secrets.AWS_S3_ENDPOINT }}
          ADMIN_SECRET=${{ secrets.ADMIN_SECRET }}
          EOF

      - name: Run unit tests
        run: |
          docker compose -f docker-compose.prod.yml build core-unit-tests
          docker compose -f docker-compose.prod.yml run --rm core-unit-tests

      - name: Upload unit test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: allure-results/

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    if: ${{ needs.unit-tests.result == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Compose
        uses: docker/setup-buildx-action@v3

      - name: Create .env file
        run: |
          cat << EOF > .env
          HTTP_HOST=${{ secrets.HTTP_HOST }}
          REDIS_HOST=${{ secrets.REDIS_HOST }}

          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_SSLMODE=${{ secrets.DB_SSLMODE }}

          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}

          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_S3_FORCE_PATH_STYLE=${{ secrets.AWS_S3_FORCE_PATH_STYLE }}
          AWS_S3_ENDPOINT=${{ secrets.AWS_S3_ENDPOINT }}
          ADMIN_SECRET=${{ secrets.ADMIN_SECRET }}
          EOF

      - name: Run integration tests
        run: |
          docker compose -f docker-compose.prod.yml build core-postgres
          docker compose -f docker-compose.prod.yml run -d --rm core-postgres

          docker compose -f docker-compose.prod.yml build core-migrate
          docker compose -f docker-compose.prod.yml run --rm core-migrate

          docker compose -f docker-compose.prod.yml build core-integration-tests
          docker compose -f docker-compose.prod.yml run --rm core-integration-tests

      - name: Upload integration test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name:  integration-test-results
          path: allure-results/

  e2e-tests:
    runs-on: ubuntu-latest
    needs: integration-tests
    if: ${{ needs.integration-tests.result == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Compose
        uses: docker/setup-buildx-action@v3

      - name: Create .env file
        run: |
          cat << EOF > .env
          HTTP_HOST=${{ secrets.HTTP_HOST }}
          REDIS_HOST=${{ secrets.REDIS_HOST }}

          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_SSLMODE=${{ secrets.DB_SSLMODE }}

          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}

          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_S3_FORCE_PATH_STYLE=${{ secrets.AWS_S3_FORCE_PATH_STYLE }}
          AWS_S3_ENDPOINT=${{ secrets.AWS_S3_ENDPOINT }}
          ADMIN_SECRET=${{ secrets.ADMIN_SECRET }}
          EOF

      - name: Start application
        run: |
          docker compose -f docker-compose.prod.yml build core-app
          docker compose -f docker-compose.prod.yml run -d --rm core-app

          docker compose -f docker-compose.prod.yml build e2e-tests
          docker compose -f docker-compose.prod.yml run --rm e2e-tests

      - name: Stop application
        if: always()
        run: |
          docker compose -f docker-compose.prod.yml down

      - name: Upload e2e test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name:  e2e-test-results
          path: /allure-results/

  generate-allure-report:
    name: Generate and Publish Allure Report
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests, e2e-tests]
    if: ${{ needs.unit-tests.result == 'success' && needs.integration-tests.result == 'success' && needs.e2e-tests.result == 'success'}}
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Download unit test results
        uses: actions/download-artifact@v4
        with:
          name: unit-test-results
          path: allure-results/

      - name: Download integration test results
        uses: actions/download-artifact@v4
        with:
          name: integration-test-results
          path: allure-results/

      - name: Download e2e test results
        uses: actions/download-artifact@v4
        with:
          name: e2e-test-results
          path: allure-results/

      - name: Checkout gh-pages
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: gh-pages
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Allure
        run: |
          sudo apt-get update
          sudo apt-get install default-jre wget -y
          wget -q -O allure-2.27.0.tgz https://github.com/allure-framework/allure2/releases/download/2.27.0/allure-2.27.0.tgz
          sudo tar -zxvf allure-2.27.0.tgz -C /opt/
          sudo ln -sf /opt/allure-2.27.0/bin/allure /usr/bin/allure

      - name: Prepare results with history
        run: |
          mkdir -p combined-results
          cp -r allure-results/* combined-results/

          if [ -d "gh-pages/history" ]; then
            echo "Restoring history from gh-pages"
            mkdir -p combined-results/history
            cp -r gh-pages/history/* combined-results/history/
          fi

      - name: Generate Allure Report
        run: |
          allure generate combined-results -o allure-report --clean

      - name: Prepare gh-pages content
        run: |
          rm -rf gh-pages/*
          cp -r allure-report/* gh-pages/

      - name: Setup Git config
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Deploy to GitHub Pages
        if: always()
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: gh-pages
          force_orphan: false
          keep_files: false

      - name: Upload history for future runs
        uses: actions/upload-artifact@v4
        with:
          name: allure-history-${{ github.run_id }}
          path: gh-pages/history
          retention-days: 30
