name: CI

on:
  push:
    branches:
      - 'feature/**'
  pull_request:
    branches: [ main, develop ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Compose
        uses: docker/setup-buildx-action@v3

      - name: Create .env file
        run: |
          cat << EOF > .env
          HTTP_HOST=${{ secrets.HTTP_HOST }}
          REDIS_HOST=${{ secrets.REDIS_HOST }}
          DB_HOST=${{ secrets.DB_HOST }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_S3_FORCE_PATH_STYLE=${{ secrets.AWS_S3_FORCE_PATH_STYLE }}
          AWS_S3_ENDPOINT=${{ secrets.AWS_S3_ENDPOINT }}
          ADMIN_SECRET=${{ secrets.ADMIN_SECRET }}
          EOF

      - name: Run unit tests
        run: |
          docker compose -f docker-compose.prod.yml build core-unit-tests
          docker compose -f docker-compose.prod.yml run --rm core-unit-tests

      - name: Upload unit test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: allure-results/

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    if: ${{ needs.unit-tests.result == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Compose
        uses: docker/setup-buildx-action@v3

      - name: Create .env file
        run: |
          cat << EOF > .env
          HTTP_HOST=${{ secrets.HTTP_HOST }}
          REDIS_HOST=${{ secrets.REDIS_HOST }}

          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_SSLMODE=${{ secrets.DB_SSLMODE }}

          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}

          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_S3_FORCE_PATH_STYLE=${{ secrets.AWS_S3_FORCE_PATH_STYLE }}
          AWS_S3_ENDPOINT=${{ secrets.AWS_S3_ENDPOINT }}
          ADMIN_SECRET=${{ secrets.ADMIN_SECRET }}
          EOF

      - name: Run integration tests
        run: |
          docker compose -f docker-compose.prod.yml build core-postgres
          docker compose -f docker-compose.prod.yml run -d --rm core-postgres

          docker compose -f docker-compose.prod.yml build core-migrate
          docker compose -f docker-compose.prod.yml run --rm core-migrate

          docker compose -f docker-compose.prod.yml build core-integration-tests
          docker compose -f docker-compose.prod.yml run --rm core-integration-tests

      - name: Upload unit test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: allure-results/

  # e2e-tests:
  #   runs-on: ubuntu-latest
  #   needs: integration-tests
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Setup Docker Compose
  #       uses: docker/setup-buildx-action@v3

  #     - name: Create .env file
  #       run: |
  #         echo "DB_USER=test" >> .env
  #         echo "DB_PASSWORD=test" >> .env
  #         echo "DB_NAME=test" >> .env
  #         echo "REDIS_PASSWORD=test" >> .env
  #         echo "REDIS_PORT=6379" >> .env

  #     - name: Start application
  #       run: |
  #         docker compose -f docker-compose.prod.yml up core-app -d --build

  #     - name: Wait for application
  #       run: |
  #         sleep 30

  #     - name: Run e2e tests
  #       run: |
  #         docker compose -f docker-compose.prod.yml up e2e-tests --build --exit-code-from e2e-tests

  #     - name: Upload e2e test results
  #       if: always()
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: e2e-test-results
  #         path: services/e2e/test-results/
  #         retention-days: 30

  #     - name: Stop application
  #       if: always()
  #       run: |
  #         docker compose -f docker-compose.prod.yml down

  generate-allure-report:
    name: Generate and Publish Allure Report
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests]
    if: ${{ needs.unit-tests.result == 'success' && needs.integration-tests.result == 'success' }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          path: all-results

      - name: Checkout gh-pages for history
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: gh-pages

      - name: Install Allure
        run: |
          sudo apt-get update
          sudo apt-get install default-jre wget -y
          wget -q -O allure.tgz https://github.com/allure-framework/allure2/releases/download/2.27.0/allure-2.27.0.tgz
          sudo tar -zxvf allure.tgz -C /opt/
          sudo ln -sf /opt/allure-2.27.0/bin/allure /usr/bin/allure

      - name: Prepare results with history
        run: |
          mkdir -p allure-results
          find all-results -name "*.json" -exec cp {} allure-results/ \;

          if [ -d "gh-pages/history" ]; then
            echo "Restoring history"
            mkdir -p allure-results/history
            cp -r gh-pages/history/* allure-results/history/
          fi

      - name: Generate Allure Report
        run: |
          allure generate allure-results -o allure-report --clean

      - name: Move new history into gh-pages
        run: |
          rm -rf gh-pages/*
          cp -r allure-report/* gh-pages/
          mkdir -p gh-pages/history
          cp -r allure-report/history/* gh-pages/history/ || true

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: gh-pages
          publish_branch: gh-pages